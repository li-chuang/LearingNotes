1.hash算法
  简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数
  也可以说，hash就是找到一种数据内容和数据存放地址间的映射关系

2.hash表/散列表
  散列表，也称作哈希表，是基于“高速存取”的角度设计的，也是一种典型的“空间换时间”的做法。
  顾名思义，该数据结构能够理解为一个线性表，可是当中的元素不是紧密排列的，而是可能存在空隙。

  散列表/哈希表，是依据关键码值(key, value) 而直接进行访问的数据结构。我们只需要输入待查找的值key,就可以查找其对应的值value。

  像ArrayList或者LinkedList，都只能通过从0开始的顺序索引查找或插入，虽然有部分优化，但大致原理如此，hash顶多用来区分两者是否一致，
  可Map中不一样，不仅可以使用索引，还可以通过key找到存储的实际内容value。

  存储实际内容value的表称之为散列表/哈希表，而某种函数通过key可以找到实际值value的函数，称之为散列函数。

  例如，我有70个人的身份信息，我自然可以将它们放入List中存储，存很容易，但取得时候却得挨个比对取出，这种办法虽然空间效率高，但数据量
  上升之后，操作不方便。于是，在列表List之外，引入了hash算法的思想，将key值通过散列函数进行计算，得到具体值value的存储位置，然后在
  这个位置存入或者取出value值。
  在此，有几个问题需要注意：
  a.首先，由于不是像List那样线性排列，而是需要通过key计算具体存储位置，所以为了避免空间拥挤，一般都会将可用空间申请多一些，例如此处是
    70个人的信息，但分配的空间是100个，70/100 = 0.7 就是此散列表的负载因子，超过了负载因子即说明散列表太过拥挤，需要扩容
  b.其次，hash算法消息虽然不一样，但得到的消息摘要有可能是一致的，于是就会产生冲突，即即： key1！= key2，而  f(key1) = f(key2)，所以，
    必须要有一个比较好的冲突解决机制，这个后面再谈
  c.再次，如果散列函数不好，导致得到的消息摘要扎堆，将会导致冲突增多。于是，要选择一个好的散列函数，让不同消息得到的消息摘要尽可能
    均匀分布，减少未来的冲突

  在构造这种特殊的“查找表” 时，除了需要选择一个“好”(尽可能少产生冲突)的哈希函数之外；还需要找到一 种“处理冲突” 的方法。

3.hash/散列函数
  hash/散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位,常用的构造散列函数的方法有以下几种。


4.直接寻址法
  取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，当中a和b为常数（这样的散列函数叫做自身函数）
  例如：有一个人口统计表，记录了从1岁到100岁的人口数目，其中年龄作为关键字，散列函数就取关键字本身，如下，
	地址	a[1]	a[2]	...	a[99]	a[100]
	年龄	1	2	...	99	100
	人数	956	856	。。。	546	281
  可以看到，当需要查找某一年龄的人数时，直接查找相应的项即可，如查找99岁老人的数量，则直接读出第99项即可。


5.数字分析法
  当数据位数一致时，取数据元素关键字中某些取值较均匀的数字位作为散列地址。即当关键字的位数很多时，可以通过对关键字的各位进行分析，
  丢掉分布不均匀的位，作为哈希值。它只适合于所有关键字值已知的情况。通过分析分布情况把关键字取值区间转化为一个较小的关键字取值区间
  例1：一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，出现冲突的几率很大；而后面的数字就好很多，因此数字分析法
      就是找出数字的规律，尽可能利用这些数据来构造冲突中几率较低的散列地址。
  例2：要构造一个数据元素个数n = 80，哈希长度m = 100 的哈希表，我们只给出其中8个关键字进行分析，8个关键字如下，
      K1=61317602    K2=61326875    K3=62739628     K4=61343634    K5=62706815    K6=62774638    K7=61381262    K8=61394220
      分析上述8个关键字可知，关键字从左到右的第1、2、3、6位取值比较集中，不宜作为哈希地址，剩余的第4、5、7、8位取值比较均匀，可选取
      其中的两位作为哈希地址。
      假如选取最后两位作为哈希地址，则这8个关键字的哈希地址分别为 02，75，28，34，15，38，62，20。
  可以看到，通过这种方法，成功的缩小了关键字的取值区间。


6.折叠法
  将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。
  这种方法适用于关键字位数较多，而且关键字中每一位上数字分布大致均匀的情况。
  折叠法中数位折叠又分为移位叠加和边界叠加两种方法，移位叠加是将分割后是每一部分的最低位对齐，然后相加；
  边界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。
  例如：当哈希表长1000时，关键字key = 110108331119891,允许的地址空间为三位十进制数，它们叠加的情况如下所示
		移位叠加			边界叠加
		891				891
   		119				911
		331				331
		108				801
		110				110

   最后结果：	559				044
  此方法适用于数字位数特别多的时候


7.平方取中法
  先取关键字的平方，然后根据可使用空间的大小，选取平方数是中间几位为哈希地址。
  因为这种方法的原理是通过取平方扩大差别，平方值的中间几位和这个数的每一位都相关，则对不同的关键字得到的哈希函数值不易产生冲突，
  由此产生的哈希地址也较为均匀
  例如：若哈希表长度为1000，可选取关键字平方值的中间三位，如下所示，
	关键字		关键字的平方		哈希函数值
 	1234		1522756			227
	2143		4592449			924
	4132		17073424		734
	3214		10329796		297
  此方法适用于每一位都有高频数字出现得情况


8.基数转换法
  将十进制数X看作其他进制，比如十三进制，再按照十三进制数转换成十进制数，提取其中的若干位作为X的哈希值。
  一般取大于原来基数的数作为转换的基数，并且两个基数应该是互素的。
  例如：
  Hash(80127429) => (80127429)13 = 8*13^7+0*13^6+1*13^5+2*13^4+7*13^3+4*13^2+2*13^1+9=(502432641)10
  如果取中间三位作为哈希值，得Hash（80127429）= 432

  为了获得良好的哈希函数，可以将几种方法联合起来使用，比如先变基，再折叠或平方取中等等，只要散列均匀，就可以随意拼凑。
  

9.除留余数法
  假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为 h（k）= k  %  p ，其中 % 为模p取余运算。
  不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，容易产生同义词。
  例如：已知散列元素为(18,75,60,43,54,90,46),表长 m = 10， p = 7，则有
	h（18）=18  %  7  =  4
 	h（75）=75  %  7  =  5
	h（60）=60  %  7  =  4
	h（43）=43  %  7  =  1
	h（54）=54  %  7  =  5
	h（90）=90  %  7  =  6
	h（46）=46  %  7  =  4
  可以看到，此时的冲突较多，为减少冲突，可取较大的m值和p值，如m = p = 13，结果如下，
	h（18）=18  %  13  =  5
 	h（75）=75  %  13  =  10
	h（60）=60  %  13  =  8
	h（43）=43  %  13  =  4
	h（54）=54  %  13  =  2
	h（90）=90  %  13  =  12
	h（46）=46  %  13  =  7
  此时则没有冲突。
  理论研究表明，除留余数法的模p取不大于表长且最接近表长m素数时效果最好，且p最好取1.1n～1.7n之间的一个素数（n为存在的数据元素个数）


10.随机乘数法
  也可以称之为“乘余取整法”。
  随机乘数法使用一个随机实数f,0≤f<1,乘积f*k的分数部分在0～1之间，用这个分数部分的值与n（哈希表的长度）相乘，乘积的整数部分就是对应的
  哈希值，显然这个哈希值落在0～n-1之间。其表达公式为：Hash(k)=「n*(f*k%1)」 ,其中“f*k%1”表示f*k 的小数部分，即f*k%1=f*k-「f*k」
  例如，对下列关键字值集合采用随机乘数法计算哈希值，随机数 f = 0.103149002 哈希表长度n = 100，情况如下所示，
