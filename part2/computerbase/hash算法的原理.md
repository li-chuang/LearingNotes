1.hash算法
  简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数
  也可以说，hash就是找到一种数据内容和数据存放地址间的映射关系

2.hash表/散列表
  散列表，也称作哈希表，是基于“高速存取”的角度设计的，也是一种典型的“空间换时间”的做法。
  顾名思义，该数据结构能够理解为一个线性表，可是当中的元素不是紧密排列的，而是可能存在空隙。

  散列表/哈希表，是依据关键码值(key, value) 而直接进行访问的数据结构。我们只需要输入待查找的值key,就可以查找其对应的值value。

  像ArrayList或者LinkedList，都只能通过从0开始的顺序索引查找或插入，虽然有部分优化，但大致原理如此，hash顶多用来区分两者是否一致，
  可Map中不一样，不仅可以使用索引，还可以通过key找到存储的实际内容value。

  存储实际内容value的表称之为散列表/哈希表，而某种函数通过key可以找到实际值value的函数，称之为散列函数。

  例如，我有70个人的身份信息，我自然可以将它们放入List中存储，存很容易，但取得时候却得挨个比对取出，这种办法虽然空间效率高，但数据量
  上升之后，操作不方便。于是，在列表List之外，引入了hash算法的思想，将key值通过散列函数进行计算，得到具体值value的存储位置，然后在
  这个位置存入或者取出value值。
  在此，有几个问题需要注意：
  a.首先，由于不是像List那样线性排列，而是需要通过key计算具体存储位置，所以为了避免空间拥挤，一般都会将可用空间申请多一些，例如此处是
    70个人的信息，但分配的空间是100个，70/100 = 0.7 就是此散列表的负载因子，超过了负载因子即说明散列表太过拥挤，需要扩容
  b.其次，hash算法消息虽然不一样，但得到的消息摘要有可能是一致的，于是就会产生冲突，即即： key1！= key2，而  f(key1) = f(key2)，所以，
    必须要有一个比较好的冲突解决机制，这个后面再谈
  c.再次，如果散列函数不好，导致得到的消息摘要扎堆，将会导致冲突增多。于是，要选择一个好的散列函数，让不同消息得到的消息摘要尽可能
    均匀分布，减少未来的冲突

  在构造这种特殊的“查找表” 时，除了需要选择一个“好”(尽可能少产生冲突)的哈希函数之外；还需要找到一 种“处理冲突” 的方法。

3.hash/散列函数
  hash/散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位：

