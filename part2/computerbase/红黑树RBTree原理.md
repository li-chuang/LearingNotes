1.红黑树（Red Black Tree,RBT）在数据结构中的位置
  在JDK源码中，有TreeMap与JDK8中的HashMap都在使用红黑树去存储
  红黑树可以看做是B树的一种：
    从二叉树看，红黑树是一种相对平衡的二叉树
    二叉树 ->  搜索二叉树 ->  平衡搜索二叉树 ->  红黑树

  从N阶树来看，红黑树就是一颗2-3-4树
    N阶树 ->  B(B-)树


2.红黑树特征，以及保持的手段
  a) 根和叶子节点都是黑色的
  b) 不能有连续两个红色的节点
  c) 从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点，
     或者说，所有叶子节点到根节点途经的黑色节点数目是一样的。
 
  这几个特效，个人理解就是给2-3-4的B树转换为红黑树量身定做的，从而满足了O(lgN)查找效率的要求

  红黑树转换为2-3-4树：
    将红黑树的红色节点与其父节点的连线涂成红色，涂色完成后，将着色后的红色斜线水平放置，然后去掉红线，将红线两端的节点合并成“3节点”或“4节点”，
    于是一颗红黑树就转变成了一颗2-3-4树
  2-3-4树转换为红黑树：
    在2-3-4树中，除了2节点外，将“3节点”和“4节点”的节点中数据用红线隔开，然后将“3节点”或“4节点”分解，再将红线向左下倾斜，注意是向左下倾斜，
    假如父节点的左右两支都是红线，可以不做处理，其它的情况需要进行一定量的旋转；最后将红线下端的节点涂成红色即可，一个红黑树就完成了。


3.红黑树的由来
  一般来说，存储数据用队列比较好，空间利用率高，查询比较快。
  可是，如果既需要查询，也需要频繁的插入和删除，队列就不是一个好的选择了，于是“树结构”就应运而生了。
  树结构虽然实现起来比队列复杂，而且空间占用也多，但好处确实也是非常明显的。

  搜索二叉树就有一个好处，根节点左边的都是比它小的，根节点右边的都是比它大的，其他节点对于其左右两部分，也遵循这一规律。这相对于队列非常占优势的一点
      在于，搜索二叉树纯天然使用了“二分查找法”。

  可是，搜索二叉树也有缺点，就像使用了“二分查找法”的队列也有这个缺点一样，假如搜索二叉树的根节点是最小值或者最大值，那么最终形成的搜索二叉树将
      是向左倾斜的一长条或者向右倾斜的一长条。

  这时，时间复杂度为O(N)，也就是和队列没区别了。
  要怎样才能达到时间复杂度O(lgN)的理想效果呢？平衡搜索二叉树(平衡二叉查找树,简称AVL)可以。
  AVL可以保持二叉树的动态平衡，即在插入、删除的情况下，搜索二叉树会通过旋转保持平衡，依然能够保证时间复杂度O(lgN)的理想状况。
  不过，AVL虽然好处多多，但实现起来也是特别的麻烦，插入、删除效果不佳，在实际环境中也没有多少使用。

  在一颗含有N个结点的树中，我们希望树高为~lgN，这样我们就能保证所有查找都能在~lgN此比较内结束，就和二分查找一样。不幸的是，在动态插入中保证树的完美平衡
      的代价太高了。我们放松对完美平衡的要求，使符号表API中所有操作均能够在对数时间内完成。

  为了保证搜索二叉树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个节点保存多个键，于是有了“2节点”、“3节点”、“4节点”的说法。
  
