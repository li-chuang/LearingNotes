1.红黑树（Red Black Tree,RBT）在数据结构中的位置
  在JDK源码中，有TreeMap与JDK8中的HashMap都在使用红黑树去存储
  红黑树可以看做是B树的一种：
    从二叉树看，红黑树是一种相对平衡的二叉树
    二叉树 ->  搜索二叉树 ->  平衡搜索二叉树 ->  红黑树

  从N阶树来看，红黑树就是一颗2-3-4树
    N阶树 ->  B(B-)树


2.红黑树特征，以及保持的手段
  a) 根和叶子节点都是黑色的
  b) 不能有连续两个红色的节点
  c) 从任一节点到它所能到达得叶子节点的所有简单路径都包含相同数目的黑色节点，
     或者说，所有叶子节点到根节点途经的黑色节点数目是一样的。
 
  这几个特效，个人理解就是给2-3-4的B树转换为红黑树量身定做的，从而满足了O(lgN)查找效率的要求

  红黑树转换为2-3-4树：
    将红黑树的红色节点与其父节点的连线涂成红色，涂色完成后，将着色后的红色斜线水平放置，然后去掉红线，将红线两端的节点合并成“3节点”或“4节点”，
    于是一颗红黑树就转变成了一颗2-3-4树
  2-3-4树转换为红黑树：
    在2-3-4树中，除了2节点外，将“3节点”和“4节点”的节点中数据用红线隔开，然后将“3节点”或“4节点”分解，再将红线向左下倾斜，注意是向左下倾斜，
    假如父节点的左右两支都是红线，可以不做处理，其它的情况需要进行一定量的旋转；最后将红线下端的节点涂成红色即可，一个红黑树就完成了。


3.红黑树的由来
  一般来说，存储数据用队列比较好，空间利用率高，查询比较快。
  可是，如果既需要查询，也需要频繁的插入和删除，队列就不是一个好的选择了，于是“树结构”就应运而生了。
  树结构虽然实现起来比队列复杂，而且空间占用也多，但好处确实也是非常明显的。

  搜索二叉树就有一个好处，根节点左边的都是比它小的，根节点右边的都是比它大的，其他节点对于其左右两部分，也遵循这一规律。这相对于队列非常占优势的一点
      在于，搜索二叉树纯天然使用了“二分查找法”。

  可是，搜索二叉树也有缺点，就像使用了“二分查找法”的队列也有这个缺点一样，假如搜索二叉树的根节点是最小值或者最大值，那么最终形成的搜索二叉树将
      是向左倾斜的一长条或者向右倾斜的一长条。

  这时，时间复杂度为O(N)，也就是和队列没区别了。
  要怎样才能达到时间复杂度O(lgN)的理想效果呢？平衡搜索二叉树(平衡二叉查找树,简称AVL)可以。
  AVL可以保持二叉树的动态平衡，即在插入、删除的情况下，搜索二叉树会通过旋转保持平衡，依然能够保证时间复杂度O(lgN)的理想状况。
  不过，AVL虽然好处多多，但实现起来也是特别的麻烦，插入、删除效果不佳，在实际环境中也没有多少使用。

  在一颗含有N个结点的树中，我们希望树高为~lgN，这样我们就能保证所有查找都能在~lgN此比较内结束，就和二分查找一样。不幸的是，在动态插入中保证树的完美平衡
      的代价太高了。我们放松对完美平衡的要求，使符号表API中所有操作均能够在对数时间内完成。

  为了保证搜索二叉树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个节点保存多个键，于是有了“2节点”、“3节点”、“4节点”的说法，这就是2-3-4树。

  比如说，对原本还是完全平衡的搜索二叉树，现在插入了一个新元素，这个元素势必打破原有的平衡，然后通过一系列的旋转达到新的平衡。
  但是在2-3-4树中，却不必如此麻烦，仅仅将多个键挤在一个节点里面即可，最多可以存放三个键，当第四个键要插入时，先将三键中间一位上移与父节点合并，剩下的两个键
      各自分配一个节点，最后将第四个键与前面剩下两个键中的一个共用节点。

  可以发现，2-3-4树的结构是由下向上生长，在最底下一层插入数据，假如节点键的数量没有超过3个，那么它们可以挤在一起，如果第四个键插入，将中间的键向上与父节点
      的键合并，假如父节点原本也有三个键，依次类推，将中间的键继续上移即可。

  可以发现，一颗2-3-4树的底部是平的，不断插入数据将使树向上生长；当然，不但的删除数据，也将使树从上至下萎缩。
  但必须保证：一颗完美平衡的2-3-4查找树中的所有空链接到根结点的距离都是相同的。
  底部的区间范围，其实是不动的。

  假如不是很明确，可以参考：
  http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf

  完美平衡的2-3-4树要平展的多。例如，含有10亿个结点的一颗2-3树的高度仅在19到30之间。我们最多只需要访问30个结点就能在10亿个键中进行任意查找和插入操作。
  
  相比AVL树，2-3-4树在维持平衡上确实比较简单有效，但维护不同类型的节点又的确很复杂，我们非常贪婪，速度要越快越好，代码要越少越好。

  办法是有的，将一个节点多个键之间用“红线”标识就可以解决问题了，按照“要点2”中的做法，很容易在2-3-4树与红黑树之间进行转换。

  于是，在2-3-4树的基础上，红黑树正式走上前台。

  注意：红黑树的使用，不是拍脑袋决定的，而是不断的实践，不断比较后做出的选择，有来龙，也有去脉。理顺它的原理然后去理解它，总比死记硬背好，比如红节点的几个特点,
        那纯粹就是后来总结的，对理解是没有什么好处的。
 
  网上大多讲解红黑树结构的资料总是告诉我们红黑树的这个性质那个性质，插入删除要注意红黑树12345特性，但是基本都没有讲为什么这样定义红色和黑色，更直接省略了讲红黑树
  的根本模型：用二叉搜索树实现的平衡2-3-4树
  

4.基于2-3-4树视角的红黑树删除操作
  删除的诀窍是：保证被删除的一定是红色末端节点，如果不是红色就想办法把它变成红色，就是说最后真正出现删除操作的key所在的2-3-4树节点里的key数量一定是大于等于2的

  这时候就需要想一些花招，从一开始就必须从上面，左或者右把其它节点的key借过来，免得删除操作出现在一个key的节点中，破坏树的平衡性。
  举个例子，下图中删除“2”：
				5  -  16
			      /   \      \
 			    2      8      19 
            		  /  \   /   \    / \      
  		     0 - 1    4 6  11-13  17 20 
  说明：此图中0,5,11是红色，其他都是黑色
  我们现在就来删除“2”节点，不过“2”节点是一个二叉节点，只有一个key，删除此节点会导致2-3-4树变形，不符合“删除的诀窍”，所以，现在需要在要删除节点“2”的路径上
  进行借调，确保“2”所在节点的key是大于或等于两个的，这一过程，称之为“预合并”，与插入过程中的“预分裂”对应。
  i.第一个2-3节点是2个key的，不需要变换，2比5小，向左遍历
  ii.遇到一个单key（2）节点(该点是黑，该点的左子还是黑)，这时可以从上面拿一个key（5）下来，和右兄弟key（8）组成一个3key节点进行“预合并”，如图
				      16
			    	 /         \				
     		         2  -  5  -  8      19
  		        / \        /   \    /  \     
		   0 - 1   4     6  11-13   17  20                              
  说明：此图中0,2,8,11是红色，其他都是黑色
  iii.这时找到要删除的key（2），把该key（2）的右子树的最小key（4）交换位置，如图。
				      16
			    	 /         \				
     		         4  -  5  -  8      19
  		        / \        /   \    /  \     
		   0 - 1   2     6  11-13   17  20   
  说明：此图中0,4,8,11是红色，其他都是黑色
  iv.继续向下变换，为了保证key（2）存在一个2key的节点中，即使出现了右红节点也没关系。这里将key（4）做了一个右旋操作，相当于从左节点拿了一个key（1）
				      16
			    	 /         \				
     		         1  -  5  -  8      19
  		       /   \       /   \    /  \     
		      0  2- 4     6 11-13  17  20   
  说明：此图中1,2,8,11是红色，其他都是黑色
  v.此时2是红key，所在的节点是一个2key节点，ok！直接删除2。
				      16
			    	 /         \				
     		         1  -  5  -  8      19
  		        / \        /   \    /  \     
		       0   4      6  11-13  17  20 
  说明：此图中1,8,11是红色，其他都是黑色 
  vi.别忘了还要修复那些不稳定的节点，修复是从树底下往上修复，和插入操作的修复是一样的，如果你用的是递归写法，只需要把修复操作放在递归操作的后面即可
				5  -  16
			      /   \      \
 			    1      8      19 
            		  /  \   /   \    / \      
  		         0    4 6  11-13  17 20 
  说明：此图中5,11是红色，其他都是黑色 

  以上就是2-3-4树视角下的红黑树删除操作，注意的要点有：
  a.删除之前在被删除节点那一支进行“预合并”，避免删除操作出现在一个key的节点中，破坏树的平衡性。
  b.被删除的节点需要转移到2-3-4树的最底下一层，对应到红黑树的操作中，就是“被删除节点后继key(4)代替被删除节点key(2)”，iii中就是如此
    另外，对于那些被删除节点只有左/右子节点的情况，通过红黑树的特征可知，单独存在的左/右子节点一定是红色，续接上即可
  c.被删除节点转移到最底层后，还需要确保此节点中有不止一个key，可以从父节点或者兄弟节点中“借用”一个key过来，此“借用”过程对应到红黑树的操中，就是旋转，如iv



