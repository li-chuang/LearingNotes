1.机器数与真值
  一个数在计算机中的二进制表示形式，叫做这个数的机器数。
  机器数是带符号的，在计算机中用一个数的最高位存放符号，正数为0，负数为1
  例如：十进制3，转换为二进制就是00000011，如果是-3，就是10000011
       那么，这里的00000011和10000011就是机器数

  因为第一位是符号位，所以机器数的形式值不等于正真的数值（例如10000011）。
  所以，为区别起见，将带符号位的机器数对应的真正数值成为机器数的真值
  例如：10000011形式上为131，但真值为-3
        0000 0001的真值= +000 0001 = +1
        1000 0001的真值= -000 0001 = -1


2.原码，反码，补码的基础概念和计算方法
  i.原码就是符号位加上真值的绝对值，即用第一位表示符号位，其余位表示值，比如：
    +1 的原码= 0000 0001
    -1 的原码= 1000 0001
    注意第一位是符号位，真正在表示数值的是后面七位，所以8位二进制数的取值范围就是：
    [1111 1111 , 0111 1111]
    即
    [-127 , 127]
    原码是人脑最容易理解和计算的表示方式.

  ii.正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余位取反
    +1 的原码= 0000 0001 反码= 0000 0001
    -1 的原码= 1000 0001 反码= 1111 1110
    对于反码，人脑无法直接的看出它的数值，通常需要转换为原码再计算
 
  iii.正数的补码就是其本身，负数的补码就是在反码的基础上+1
    +1 的原码= 0000 0001 反码= 0000 0001 补码= 0000 0001
    -1 的原码= 1000 0001 反码= 1111 1110 补码= 1111 1111
    对于补码，人脑也无法直接的看出它的数值，通常需要转换为原码再计算


3.为何要使用原码、反码和补码
  对于一个正数，它的原码、反码和补码都是一样的，如：
	+1 的原码= 0000 0001 反码= 0000 0001 补码= 0000 0001
  所以不需要过多解释，但是对于负数，情况就不一样了，如：
  	-1 的原码= 1000 0001 反码= 1111 1110 补码= 1111 1111

  对于人脑来说，原码才是最好识别并且使用的编码形态，可是对于计算机来说，情况却不是这样。
  首先，人脑可以识别原码的第一位是符号位，在计算的时候，我们可以根据符号位，选择对真值区域的
    的加减；可是对计算机来说，这样的基础运算要尽量简单，让计算机辨别‘符号位’无疑会使计算机
    的基础电路设计变得非常复杂，于是人们想出了将符号位也参与运算的方法。

  于是人们开始探索，将符号位参与运算，并且只保留加法的方法，首先看原码：
  计算十进制的表达式：1 - 1 = 0
  	1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [1000 0010]原 = -2
  以上结果说明，如果用原码表示，让符号位也参与运算，结果是不正确的，所以计算机内部不使用原码表示
  一个数；

  为了解决上面的问题，出现了反码：
  还是计算十进制的表达式：1 - 1 = 0
	1 - 1 = 1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
  发现用反码计算减法，结果的真值部分是正确的。而唯一的问题出现在‘0’这个特殊符号上，‘0’带符号
  其实是没有意义的，而且有[0000 0000]原 与 [1000 0000]原 两个编码表示0.

  于是补码的出现，解决了‘0’的符号以及两个编码的问题： 
  还是计算十进制的表达式：1 - 1 = 0
	1 - 1 = 1 + (-1) = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原
  这样0就可以用[0000 0000]表示，而原来的-0则不存在了，空出来的[1000 0000]可以用来表示-128

  注意：-1-127用原码计算的结果是错的，用反码计算的结果是[1000 0000]反，结果是-0也不对，
       但是用补码来计算，就可以得到[1000 0000]补，用来表示-128，（-128并没有原码与反码表示）

  使用补码，是综合权衡的结果，补码不仅可以让符号位参与计算，而且修复了0的符号问题，多表示一个数
  补码并非ANSI标准，只是这种表示方法最好用


4.原码、反码、补码再深入
  用原码进行计算，必须先判断加减法，不然计算出来的就是错的，符号位没办法直接参与运算
  反码巧妙的将符号加入到运算中，而结果还是对的，这是什么原因呢？
  补码在反码的基础上，负数时再加1，结果仍然是对的，这又是什么原因呢？

  为解释上面的问题，我们从钟表开始：
  如果当前时间为6点，当希望将时间设置为4点时，我们可以如下操作：
  a.往回拨2个小时：6 - 2 = 4 
  b.往前拨10个小时：(6 + 10) mod 12 = 4
  c.往前拨10 + n*12 个小时：(6 + 22) mod 12 = 4(当 n = 1时)

  所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!
  但具体是如何替代的呢？这里就需要用到‘同余’的概念了

  “同余”：两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余
  记作 a ≡ b (mod m)
  读作 a 与 b 关于模 m 同余
  4 mod 12 = 4
  16 mod 12 = 4
  28 mod 12 = 4
  所以4,16,28关于模 12 同余

  以上是正数的取模，负数取模的规则是：
  x mod y 等于 x 减去 y 乘上 x与y的商的下界。例如
  (-2) mod 12 = -2 - 12 L(-2/12)J = -2 -12*(-1) = 10
  (-4) mod 12 = -4 - 12 L(-4/12)J = -4 -12*(-1) = 8
  (-5) mod 12 = -5 - 12 L(-5/12)J = -5 -12*(-1) = 7

  基于以上的取模运算，回到时钟的问题上，可以得出这样的结论：
  回拨2小时 = 前拨10小时
  回拨4小时 = 前拨8小时
  回拨5小时 = 前拨7小时

  结合之前的概念，可以发现规律：
  	(-2) mod 12 = 10
  	(10) mod 12 = 10
  -2 与 10 是同余的
  	(-4) mod 12 = 8
  	(8) mod 12 = 8
  -4 与 8 是同余的
  -5 与 7 是同余的 ，而 12 即是它们的模

  时钟的问题理清楚了，我们再回到二进制的问题上，看一下 2 - 1 =1 的问题：
  2 - 1 = 2 + (-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]反 + [1111 1110]反

  -1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126.
  发现有如下规律：
  (-1) mod 127 = 126
  126 mod 127 = 126
  即：
  (-1) ≡ 126 (mod 127)
  2-1 ≡ 2+126 (mod 127)

  2-1 与 2+126的余数结果是相同的! 而这个余数, 正是我们的期望的计算结果: 2-1=1 

  所以说一个数的反码, 实际上是这个数对于一个模的同余数

  一个八位的存储单元可以和钟表对比，存储块最多存1111 1111 ，再往上加 1，数值是1 0000 0000(注意，有9位)
  因为存储单元只可以存8位，导致存储块的值为0000 0000 ，这也是一种轮回

  设想一个有127个刻度的轮盘，现在指针在‘2’的位置，实际上，往回拨1格，与向前拨126格是一致的
  而‘-1’与‘126’的二进制值[1000 0001],[0111 1110]正好是反码的关系，从而除掉了讨厌的符号
  
  最后一个问题，反码可以将减法变成加法，为什么补码在反码的基础上加1，也可以得到正确的结果？
  2 - 1 = 2 + (-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补 
  计算的结果是1 0000 0001 ，但存储单元只有8位，则结果是[0000 0001] 正确
  
  如果把[1111 1111]当成原码, 去除符号位, 则
  [0111 1111]原 = 127
  其实, 在反码的基础上+1, 只是相当于增加了模的值:
  (-1) mod 128 = 127
  127 mod 128 = 127
  2-1 ≡ 2+127 (mod 128)

  此时，可以想象一个128个刻度的轮盘，向后1位与向前127位是一致的

  正数部分不需要变符号，补码也就是其本身，所以范围是[0,127]
  但负数部分有点特殊，反码之后还加1，导致它们的真值是+1了的，所以负数部分的范围是[-128,-1]
  总的范围是[-128,127]

  对于一个128格的轮盘，移动0位与移动128位是一致的，所以-0被换成了-128，扩大了数的表示范围
  总共256个转动的选项，对应着256个数

  总的来说，就是正数部分不变，负数则利用同余算法，模数取128，将此负数转化为与此数同模的正数
  然后让两个正数相加。

5.二进制数的补码等于其反码再加一的代数原理
  假设以n位二进制位来存储数据，其中最左一位为符号位
  模 = 2^(n-1) = 1 + 1*2 + 1*2^2 + ...... + 1*2^(n-2) + 1
  某负数原码 a = k0 + k1*2 + k2*2^2 + ...... + kn-2*2^(n-2)

  两个补数与对应的模的关系为: 模 = |a| + |b|
  所以a的补码 b = 2^(n-1) - a = (1-k0) + (1-k1)*2 + (1-k2)*2^2 + ...... + (1-kn-2)*2^(n-2) + 1

  由于k0,k1等的值不是0就是1，因此等价于作取反操作，然后最后再加1。








  对补码再求一次补码则得到原码，这也使得编码方式之间的转换特别简单
  



























