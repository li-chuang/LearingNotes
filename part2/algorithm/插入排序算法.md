1.插入排序，排序过程以数组{38,65,97,76,13,27,49}为例
  第一趟
  [38] 65,97,76,13,27,49  最开始，已排部分为空，数据全部在未排部分，从未排部分取出一个数38进入已排部分进行比较
  第二趟
  [38,65] 97,76,13,27,49  从未排部分取出65，进入已排部分进行比较，放在相应位置
  第三趟
  [38,65,97] 76,13,27,49  从未排部分取出97，...
  第四趟
  [38,65,76,97] 13,27,49  从未排部分取出76，经大小比较后插入对应位置，此时97要移位
  第五趟
  [13,38,65,76,97] 27,49  从未排部分取出13，经大小比较后插入对应位置，此时38,65,76,97都要移位
  第六趟
  [13,27,38,65,76,97] 49  剩下的也是如此。。。
  第七趟
  [13,27,38,49,65,76,97]
  

2.基本思想
  非常类似于整理扑克牌，在牌堆中一张张拿牌，然后依次按大小插入左手中。
  比如手上已经有了“3”，“5”，“10”，然后又从牌堆中拿了张“7”，经比较后放在“5”与“10”之间
  插入排序道理是一样的，
  将待排数组分成两部分：已排部分，未排部分。已排部分最开始只有一条，然后不断从未排部分取出值，
  经比对后插入已排部分的正确区域，直到未排部分没有数据，

3.基本操作
  将一个记录插入到已经排序好的有序表中，从而得到一个新的、记录数增1的有序表。
  对于给定的一组记录，初始时假定第一个记录自成一个有序序列，其余记录为无序序列，
  接着从第二个记录开始，按照记录的大小依次将当前处理的记录插入到其之前的有序序列中，
  直到最后一个记录插入到有序序列中为止。


4.复杂度分析
  最好的情况，也就是要排序的表本身就是有序的，此时只有数据比较，没有数据移动，时间复杂度为O(n)
  最坏的情况，即待排序的表是逆序的情况，此时需要比较次数为2+3+...n = (n+2)(n-1)/2，而记录移动的
    最大值也达到了(n+4)(n-1)/2次；
  空间复杂度是一样的，都是O(1)；

  如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为n2/4，因此，得出直接插入排序发的时间复杂度为O(n2)。
  从这里可以看出，同样的是时间复杂度O(n2)，直接插入排序法比冒泡和简单选择排序的性能要好一些。


5.代码示例
  public static void insertSort(int[] a) {
        int i, j, insertNote;// 要插入的数据
        for (i = 1; i < a.length; i++) {// 从数组的第二个元素开始循环将数组中的元素插入
            insertNote = a[i];// 设置数组中的第2个元素为第一次循环要插入的数据
            j = i - 1;
            while (j >= 0 && insertNote < a[j]) {
                a[j + 1] = a[j];// 如果要插入的元素小于第j个元素,就将第j个元素向后移动
                j--;
            }
            a[j + 1] = insertNote;// 直到要插入的元素不小于第j个元素,将insertNote插入到数组中
        }
  }
