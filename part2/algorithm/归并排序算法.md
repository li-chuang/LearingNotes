1.归并排序，以{50,10,90,30,70,40,80,60,20}数组为例

  首先，不断分治，也就是拆分，最终拆成n个长度为1的有序序列
  [50,10,90,30,70] [40,80,60,20]
  [50,10,90] [30,70] [40,80] [60,20]
  [50] [10] [90] [30] [70] [40] [80] [60] [20] 

  然后，不断合并排序好的序列，生成排序结果
  [10,50] [90] [30,70] [40,80] [20,60]
  [10,50,90] [30,70] [40,80] [20,60]
  [10,30,50,70,90] [20,40,60,80]
  [10,20,30,40,50,60,70,80,90]

2.归并排序原理
  归并是将两个（或两个以上）有序表合并成一个新的有序表。归并排序就是利用归并的思想实现的排序方法。
  对于给定的一组记录，利用递归与分治技术将数据序列划分成为越来越小的子序列，然后将已有序的子序列
    合并，得到完全有序的序列，最终合并为有序表。
  如果是将两个有序表合并成为一个有序表，称为2路归并


3.递归排序算法思想
  分而治之（divide - conquer）
  每个递归过程涉及三个步骤
  第一，分解：把待排序的n个元素的序列分解成两个子序列，每个子序列包括n/2个元素
  第二，治理：对每个子序列分别调用归并排序的MergeSort，进行归并操作
  第三，合并：合并两个排好序的子序列，生成排序结果 


4.代码示例
    public static void merge(int[] a, int low, int mid, int high) {  // 这里是两条有序序列归并为一条有序序列
        int[] temp = new int[high - low + 1];
        int i = low;// 左指针
        int j = mid + 1;// 右指针
        int k = 0;
        // 把较小的数先移到新数组中
        while (i <= mid && j <= high) {
            if (a[i] < a[j]) {
                temp[k++] = a[i++];
            } else {
                temp[k++] = a[j++];
            }
        }
        // 把左边剩余的数移入数组
        while (i <= mid) {
            temp[k++] = a[i++];
        }
        // 把右边边剩余的数移入数组
        while (j <= high) {
            temp[k++] = a[j++];
        }
        // 把新数组中的数覆盖nums数组
        for (int k2 = 0; k2 < temp.length; k2++) {
            a[k2 + low] = temp[k2];
        }
    }

    public static void mergeSort(int[] a, int low, int high) {  // 这个方法是核心
        int mid = (low + high) / 2;
        if (low < high) {
            // 左边
            mergeSort(a, low, mid);	//此处进行分治，分治后认为此部分的数据是有序的
            // 右边
            mergeSort(a, mid + 1, high); //此处进行分治，分治后认为此部分的数据是有序的
            // 左右归并
            merge(a, low, mid, high);	// 分治后的前后两段有序序列，将它们归并成一条有序序列
        }

    }

5.归并算法的扩展
  上面的归并算法，因为将数据分成了两部分进行处理，所以称之为二路归并，
  除此之外，还可以将数据分成3部分以至n部分进行处理的情况，称之为三路归并、多路归并。实际上它们的思想是一致的

  先分成多个部分进行分治，然后将多段有序序列归并成一条有序序列
