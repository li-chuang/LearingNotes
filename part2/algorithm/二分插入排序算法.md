1.二分插入排序算法是直接插入排序算法的优化
  区别是：在有序区中查找新元素插入位置时，为了减少元素比较次数，提高效率，采用二分查找算法进行插入位置的确定。

  在排序数据量比较大的时候，二分插入排序的速度就要远远高于直接插入排序。

2.二分查找举例：
  前面已经排好序，还剩最后一个数在无序序列中，在此基础上，对最后一个数排序：
  [4,9,12,14,15,18,23] 6

  此时，mid = 14 ，6 < 14,经比较后确定插入位置应该在14前面，修改low = 4, mid = 9, hight = 12
  当    mid = 9  ，6 < 9, 经比较后确定插入位置应该在9前面，由于low + 1 = mid，即low与mid相邻
  确定插入位置为“9”处
  

3.二分插入排序原理
  二分插入排序通过从第二个数开始将需要排序的数分为两个部分，左边部分有序，右边部分无序，然后将右边部分第一个
  数开始，一个个插入前面有序部分。
  与直接插入排序唯一不同的是：二分插入排序会先找出左边有序部分的中间值，然后与需要插入的值比较，所以在插入之前，
  不断进行折半后比较，快速的确定出第i个元素要插在什么地方。
  因此，在数据量比较大的时候，二分插入排序算法就更加高效，速度更快。


4.代码示例
  public static void binarySort(int[] source) { 
    	int i, j; 
    	int high, low, mid; 
    	int temp; 
    	for (i = 1; i < source.length; i++) { 
      		// 查找区上界 
      		low = 0; 
      		// 查找区下界 
      		high = i - 1; 
      		//将当前待插入记录保存在临时变量中 
      		temp = source[i]; 
      		while (low <= high) { 
        		// 找出中间值 \
        		mid = (low + high) >> 1; 
        		//如果待插入记录比中间记录小 
        		if (temp<source[mid] ) { 
          			// 插入点在低半区 
          			high = mid - 1; 
        		} else { 
          			// 插入点在高半区 
          			low = mid + 1; 
        		} 
      		} 
       		//将前面所有大于当前待插入记录的记录后移  
      		for (j = i - 1; j >=low; j--) { 
        		source[j + 1] = source[j]; 
      		} 
      		//将待插入记录回填到正确位置.  
      		source[low] = temp; 
      		System.out.print("第" + i + "趟排序："); 
      		printArray(source); 
    	} 
  } 
