1.DualPivotQuicksort快速排序与TimSort归并插入混合排序都出现先JDK1.7之后Arrays工具类的排序方法sort()中，只不过它们的使用有些差别，
  基本数据类型和对象采用了不同的排序算法。
  对基本类型，采用DualPivotQuicksort排序算法，如下：
  public static void sort(int[] a){
	DualPivotQuicksort.sort(a);
  } 
  对于Object类型，采用ComparableTimSort排序算法，如下：
  public static void sort(Object[] a) {
    	if (LegacyMergeSort.userRequested)
        	legacyMergeSort(a);
    	else
        	ComparableTimSort.sort(a);
  }
  为什么会出现这样的选择呢？理由如下：
  a.DualPivotQuicksort快速排序不稳定，对基本类型几乎没有影响，但对Object类型影响很大，所以对Object类型不能使用快速排序，
    与此同时，归并排序很稳定，于是Object类型使用的是归并排序
  b.快速排序采用递归实现，当数组规模太大时，有可能堆栈溢出，而归并排序采用非递归实现，不存在此问题，
    纯基本数据类型数据量不会太大，用快速排序可行，但当数据量太多的时候，还是得使用诸如归并排序这种内存消耗不大的排序方式。


2.双轴快排与一般快排的差别
  一般的快速排序采用一个枢轴来把一个数组划分为两半，然后递归之。
  如选取第一个数作为中轴，通过不断比较与换位，最终以此中轴为界，左边的小于此中轴，右边的大于此中轴，然后左右两边再进行递归，直到全部排序完毕。
  而双轴快排采用两个枢轴（P1, P2），将数组分成三份（小于P1，大于P1小于P2，大于P2），然后剩下的三部分分别递归，直到全部排序完毕。


3.算法思想
  选出两个枢轴P1和P2，一般是数组的头和尾的值，然后设置3个指针L，K，G。其中L从头开始向后，G从后开始向前，K则作为(P1 <= & <= P2)与未排序部分的分界线
  算法的步骤如下：
  a.小于27(或47)的数组，使用插入排序
  b.选择枢轴P1和P2。（假设使用数组头和尾）
  c.P1需要小于P2，否则交换
  d.通过两个轴的设定，将整个数组分成四个部分：
	i.第一部分，比P1小的元素
	ii.第二部分，比P1大但是比P2小的元素
 	iii.第三部分，比P2大的元素
   	iv.第四部分，待比较的元素
	在开始比较前，除了轴点，其余元素几乎都在第四部分，直到比较完之后第四部分没有元素
  e.从第四部分选出一个元素a[K]，与两个轴心比较，然后放到第一二三部分中的一个
	i.当大于P1小于P2，K++，然后继续扫描
	ii.当小于P1，L++，交换L和K的数，K++
	iii.当大于P2，这个时候，就要考虑到右边值a[--G]的情况了，
		1)如果a[G] > P2，将G左移
		2)如果 P1 <= a[G] <= P2，交换K和G，并K++
		3)如果a[G] < P1，把L上的数放在K上，把G的数放在L上，L++，再把K以前的数放在G上，K++，完成一次L,K,G的互相交换
  f.重复第e步，直到第四部分为空
  g.将P1与第一部分的最后一个元素交换。将P2与第三部分的第一个元素交换。
  h.将第一二三部分递归排序

  注意：P1 和 P2 始终不参与K,G扫描过程，始终保持最左边和最右边的元素，即双轴，不发生交换
	扫描结束时，K==G，a[L]表示了小于P1部分的最后一个元素，a[G]表示了大于P2的第一个元素，最后将这三个部分继续递归即可


4.示意图
                    left part         center part                  right part
                  +----------------------------------------------------------+
                  | == pivot1 |  pivot1 < && < pivot2  |    ?    | == pivot2 |
                  +----------------------------------------------------------+
                               ^                        ^       ^
                               |                        |       |
                              less                      k     great


5.举例4,3,5,9,8,2,1,7,6（短于27的数组直接使用插入排序，这里主要是演示双轴快速排序执行过程，不考虑长度的问题）

  P1 = 4，P2 = 6

  4,3,5,9,8,2,1,7,6	一般取前后两位为中枢轴，两者中小的放前面，大的放后面，不一致时先交换一下位置，保证 P1 < P2
  L K             G	然后设置3个指针，其中 K 指针是取值核心，L 指针从左向右移动，G 指针从右向左移动

  4,3,5,9,8,2,1,7,6	取a[K]的值3，与P1,P2进行比较，a[K] < P1，L++，交换L和K的数，K++
  L K             G   

  4,3,5,9,8,2,1,7,6	取a[K]的值5，与P1,P2进行比较，P1 < a[K] < P2，此时，K所处的值可以继续放在原来的位置，符合设计，K++
    L K           G

  4,3,5,9,8,2,1,7,6	取a[K]的值9，与P1,P2进行比较，a[K] > P2，此时，将视线转移到右边，比较前，将G指针左移一位
    L   K         G

  4,3,5,9,8,2,1,7,6	取a[G]的值7，与P1,P2进行比较，a[G] > P2，此时，将G指针左移一位
    L   K       G

  4,3,5,9,8,2,1,7,6	取a[G]的值1，与P1,P2进行比较，a[G] < P1，此时，将L，K，G的数据进行调换，L->K，G->L，然后L++，K->G，最后，K++
    L   K     G

  4,1,5,3,8,2,9,7,6	取a[K]的值8，与P1,P2进行比较，a[K] > P2，此时，将视线转移到右边，比较前，将G指针左移一位
      L   K   G

  4,1,5,3,8,2,9,7,6	取a[G]的值2，与P1,P2进行比较，a[G] < P1，此时，将L，K，G的数据进行调换，L->K，G->L，然后L++，K->G，最后，K++
      L   K G

  4,1,2,3,5,8,9,7,6	此时 K==G，a[L]=3 表示了小于P1部分的最后一个元素，a[G]/a[K]=8 表示了大于P2的第一个元素
        L   K(G)

  {4,1,2,3},5,{8,9,7,6}	将 P1=4 与第一部分的最后一个元素 a[L]=3 交换，将P2=6 与第三部分的第一个元素 a[G]/a[K]=8 交换

  {3,1,2,4},5,{6,9,7,8}	将三个部分继续递归
