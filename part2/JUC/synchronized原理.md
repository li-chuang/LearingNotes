1.代码中synchronized 关键字的作用
  一般认为synchronized 关键字修饰的类，方法，块实现了线程的同步访问功能，实际上与事实还是有些差异的。
  其实synchronized 只是提供了多线程互斥，而对象的wait() 与notify()方法才提供线程的同步功能。


2.synchronized所谓的“加锁”是什么意思
  经常会有一种说法是调用synchronized 修饰的代码会获得锁，线程只有获得了锁才可以顺利执行。可是什么是‘锁’，这‘锁’是何种形态，却一直不太清楚。
  事实上，synchronized 只是一个Java修饰词，作用是向JVM虚拟机传递一个信号：调用此代码块的‘对象’要加‘重量锁’。剩下的事情交给‘重量锁’完成就可以了。

  于是，通常说的synchronized在方法，类或块上加锁，这里的锁就是‘重量锁’，或者说是‘对象锁’，在JVM中又叫做对象监视器(Monitor)


3.给对象加锁，是怎样一个过程
  拿一个synchronized修饰的方法sayHello() 为例:对象实例people调用了此方法sayHello()，由于sayHello()有synchronized关键字修饰，JVM虚拟机在解析的时候，
  给people对象的对象头‘MarkWord’部分进行设置，使对象状态从‘无锁态’转为‘重量级锁态’，其中有一个指针，指向的就是‘重量锁’对象。

  对象头‘MarkWord’有4个字节，32bit，它的结构大致有如下几种形式，对象状态就在这几种状态中切换
  无锁态：  对象的hashcode（25bit）+ 年龄（4bit）+ 0 + 锁标志位‘01’
  偏向锁：  线程ID与Epoch（25bit）               + 1 + 锁标志位‘01’
  轻量级锁：指向栈中锁记录的指针（30bit）+             锁标志位‘00’
  重量级锁：重量级锁的指针/Monitor address（30bit）+   锁标志位‘10’
  GC标记：  		转发地址		       锁标志位‘11’

  其中锁标志位的2bit用来显示锁类型。
  通常我们说synchronized的对象锁，就是这里锁类型为‘10’的monitor对象，这里的Monitor address就是这个monitor对象（就是重量级锁）的地址。


4.JVM切换了对象的对象头‘MarkWord’部分，将对象从无锁态转为重量级锁后，指向一个monitor对象，这个对象就是未来进行同步管理的核心。
  当多个线程同时请求synchronized方法或块时，monitor会设置几个虚拟逻辑数据结构来管理这些多线程。下图是简化了的管理结构


     ----1---->  线程队列List  ----2---->   运行的线程  ----5---->  运行结束，释放锁线程
  		      \		             /
  		       \4	            /3
			\		   /
   		           wait的线程集合

  a.请求的线程都先加入到线程队列List中
  b.线程队列List中的线程，通过‘竞争上岗’，获得CPU等资源的控制权，执行自身的任务
  c.正在运行的线程wait()等待后，放弃对资源的控制权，加入到wait线程集合中
  d.wait线程集合中的线程在notify()/notifyAll()后唤醒，又重新加入到线程队列List中，再次等待‘竞争上岗’
  e.运行结束后，释放资源，线程完成任务。

  关于‘线程队列List’，还有一些细节需要知晓，
 		1 
		 \		(Waiting Queue)		       (Ready Thread)
	      1 —  ContentionList ----2----> EntryList ----3----> OnDeck	
		 /				|		     |
		1				|6		     |4																  
						|	             |
					     WaitSet  <----5----   owner(Running Thread)
					(Bolcking Queue)

  a.线程队列不是一个真正的Queue，而是由两部分组成，ContentionList虚拟队列与EntryList，它们联合在一起才是一个真正的 Waiting Queue
  b.所有请求锁的线程都将被首先放置在Contention List竞争队列中，这是一个后进先出（LIFO）队列，节点封装为Node，有一个next指针
  c.由于Contention List会被外部（1处）线程并发访问，为了降低取节点时的争用，建立了EntryList。
    Owner线程在unlock时会从ContentionList中迁移线程到EntryList，并会指定EntryList中的某个线程（一般为Head）为Ready（OnDeck）线程
  d.任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck。
    Owner线程并不是把锁传递给OnDeck线程，只是把竞争锁的权利交给OnDeck，OnDeck线程需要重新竞争锁
  e.获得锁的线程称为Owner。OnDeck线程获得锁后立即变为owner线程，无法获得锁则会依然留在EntryList中，考虑到公平性，在EntryList中的位置不发生变化（依然在队头）
  f.如果owner线程被wait方法阻塞，则转移到WaitSet队列
  g.如果在某个时刻被notify/notifyAll唤醒，则再次转移到EntryList

  最后还要说下，让线程放弃运行有多种方式，除了wait()外，还有sleep()和yield()，它们的区别如下：
  wait()：释放锁，线程进入等待队列，当notify/notifyAll的时候才唤醒。
          所以wait与notify/notifyAll 必须成对出现，而且必须放在synchronized里(接受Monitor监控器对象管理)
  sleep():继续占着锁，一般会设置一个睡眠时间，超过时间后，继续运行，所以sleep()的整个过程，线程的状态都是owner
  yield():继续占着锁，yield方法使当前线程出让CPU占有权

  wait() 和 sleep()、yield() 最大的不同在于 wait() 会释放对象锁，而 sleep()、yield() 不会，sleep() 是让当前线程休眠，而 yield() 是让出当前 CPU。



5.重量锁，自旋锁与自适应自旋锁
  通过上面可知，synchronized实现的锁结构被称为“重量锁”，这是因为synchronized是通过对象内部的监控器（monitor）实现的。
  而监视器锁进行挂起线程和恢复线程的操作本质上依赖于底层的操作系统（Windows由Mutex Lock实现，Linxu下通过pthread_mutex_lock函数实现），都需要CPU从用户态转为核心态。
  同时，虚拟机开发团队也注意到，许多应用上的数据锁只会持续很少的一段时间，例如一个线程切换周期，这样的话在很短的时间内阻塞线程又很快唤醒线程显然不值得，所以引入了
  自旋锁概念。
  
  所谓“自旋”，就是monitor并不把线程阻塞放入排队队列，而是去执行一段时间无意义的循环，循环结束后看看是否锁已经释放并且直接进行竞争上岗步骤，如果竞争不到继续自旋循环，
  循环过程中线程的状态一直处于running状态。（明显自旋锁使得synchronized的对象锁方式在线程之间引入了不公平。但是这样可以保证大吞吐率和执行效率）
  显然，自旋并不是最好的方式，自旋方式省去了阻塞线程的时间和空间（队列的维护等）开销，如果锁被占用的时间很短，自旋等待的效果就会很好，反之，自旋就会消耗大量处理器资源。
  因此，自旋的次数必须有一定的限度，如果超过限度还没有获得锁，就要挂起线程，进入排队队列，这个限度默认是10次。

  自旋是把双刃剑，如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。显然，自旋的周期选择显得非常重要，但这与操作系统、硬件体系、系统的负载等诸多场景相关，
  很难选择，如果选择不当，不但性能得不到提高，可能还会下降，因此大家普遍认为自旋锁不具有扩展性。

  于是在这种情况下，出现了“自适应自旋锁”也就是说自旋的时间限度不是一个固定值，而是由上一次同一个锁的自旋时间及锁的拥有者状态来决定的。
  虚拟机认为，如果同一个线程对象自旋刚刚成功获得锁，那么下一次很可能获得锁，所以允许这次自旋锁自旋很长时间、而如果某个线程很少获得锁，那么以后在获取锁的过程中可能忽略到自旋过程。

  JDK对synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。


6.锁状态与锁升级
  在JDK1.6以后，为了减少获得锁和释放锁带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。
  在Java中，锁总共有四种状态，级别从低到高分别为：无状态锁，偏向锁，轻量级锁和重量级锁。这几个状态会随着竞争情况逐渐升级，而锁可以升级但是不可以降级。

  在多线程环境下，进入synchronized区域的线程没有竞争时，JVM并不会马上创建对象锁（重量锁），而是用轻量级锁和偏向锁。
  但是，首先需要强调一点的是，轻量锁和偏向锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。
  一旦出现了多线程竞争，synchronized区域的轻量锁或偏向锁都会立即升级为重量锁。


7.偏向锁
  偏向锁实际上是一对重量锁的优化，其目的是为了减少数据在无竞争情况下的性能消耗。其核心思想就是锁会偏向第一个获取它的线程，
  在接下来的执行过程中该锁没有其他的线程获取，则持有偏向锁的线程永远不需要再进行同步。（多线程环境下事实上的单线程操作）

  现在几乎所有的锁都是可重入的，也即已经获得锁的线程可以多次锁住/解锁监视对象，
  按照之前的HotSpot设计，每次加锁/解锁都会涉及到一些CAS操作（比如对等待队列的CAS操作），CAS操作会延迟本地调用，
  因此偏向锁的想法是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，
  说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。

  偏向锁获取过程：
 （1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。
 （2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。
 （3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。
 （4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
 （5）执行同步代码。

  偏向锁的释放：
  偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。
  偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，
  撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

8.轻量级锁
  轻量级锁是JDK1.6之中加入的新型锁机制，它并不是来代替重量级锁的，他的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

  轻量级锁获取过程：
 （1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，
      用于存储锁对象目前的Mark Word的拷贝。
 （2）拷贝对象头中的Mark Word复制到锁记录中。
 （3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）。
 （4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。
 （5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。
      否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 
      而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

  轻量级锁的释放：
  轻量级锁解锁时，同样通过CAS操作将对象头换回来。如果成功，则表示没有竞争发生。如果失败，说明有其他线程尝试过获取该锁，锁同样会膨胀为重量级锁。在释放锁的同时，唤醒被挂起的线程。
  

9.总结
  本文重点介绍了JDk中采用轻量级锁和偏向锁等对Synchronized的优化，但是这两种锁也不是完全没缺点的，比如竞争比较激烈的时候，不但无法提升效率，反而会降低效率，因为多了一个锁升级的过程，
  这个时候就需要通过-XX:-UseBiasedLocking来禁用偏向锁。

  偏向锁与轻量级锁理念上的区别：
  a.轻量级锁：在无竞争的情况下使用CAS操作去消除同步使用的互斥量
  b.偏向锁：在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了

  下面是几种锁的对比
  偏向锁：
  适用场景：适用于只有一个线程访问同步块的情况。只在单线程状态下起作用，即使只有一个线程运行的情况下，前后不是同一个线程，JVM都会取消偏向锁，恢复轻量锁
  优点：加锁和解锁不需要额外的消耗，和执行非同步方法仅存在纳秒级的差距
  缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗

  轻量级锁：
  适用场景：追求响应时间，同步块执行速度非常快。只在单线程状态下起作用，一有多线程竞争则膨胀为重量级锁
  优点；竞争的线程不会阻塞，提高了程序的响应速度。
  缺点：如果始终得不到锁竞争的线程使用自旋会消耗CPU。

  重量级锁；
  适用场景：追求吞吐量。同步块执行速度较长。在多线程条件下其他的锁都会膨胀为重量级锁。
  优点：线程竞争不使用自旋，不会消耗CPU。
  缺点：线程阻塞，响应时间缓慢。

  大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。
  线程之前除了互斥之外也可能发生同步关系，被同步的两个线程（一前一后）对共享对象锁的竞争很可能是没有冲突的。对这种情况，JVM用一个epoch表示一个偏向锁的时间戳
